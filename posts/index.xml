
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Posts on hhatefi</title>
   <link>https://hhatefi.github.io/posts/</link>
   <description>Recent content in Posts on hhatefi</description>
   <generator>Hugo -- gohugo.io</generator>
   <copyright>&amp;copy; 2020 - hhatefi</copyright>
   <lastBuildDate>Mon, 14 Mar 2022 21:51:00 +0100</lastBuildDate>
   
       <atom:link href="https://hhatefi.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>From echo cancellation to price prediction</title>
       <link>https://hhatefi.github.io/posts/price_prediction/</link>
       <pubDate>Mon, 14 Mar 2022 21:51:00 +0100</pubDate>
       
       <guid>https://hhatefi.github.io/posts/price_prediction/</guid>
       <description>&lt;p&gt;Echo cancellation is a technique to remove acoustic echo from audiosignal. The procedure is generally applicable to any signal, forinstance price time-series of an asset. This post proposes that theprice of an asset at any moment can be seen as the echo of its pricesat some previous moments. It then explains how price predictionproblem can be formulated and solved using echo cancellation.&lt;/p&gt;&lt;h2 id=&#34;system-identification&#34;&gt;System Identification&lt;/h2&gt;&lt;p&gt;System identification is the process of identifying an unknown systemthrough observing its input and its output. The unknown system in thiscontext is assumed to be &lt;a href=&#34;https://en.wikipedia.org/wiki/Linear%5Ftime-invariant%5Fsystem&#34;&gt;linear time-invariant&lt;/a&gt; and is specified by a&lt;a href=&#34;https://en.wikipedia.org/wiki/Finite%5Fimpulse%5Fresponse&#34;&gt;finite impulse response (FIR)&lt;/a&gt;. It is here used to predict an assetprice by looking into its price history. The FIR takes the pricehistory as the input and generates an estimation future price. Theblock diagram of the price predictor is depicted below. The system isidentifided through an adaptive process: it starts with an initial FIRand adapts it every time a new price tick comes.&lt;/p&gt;&lt;figure class=&#34;diag&#34;&gt;&lt;img src=&#34;https://hhatefi.github.io/ox-hugo/system_identification_block_diagram.svg&#34;         alt=&#34;Figure 1: System Identification&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Figure 1: System Identification&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;In each adaptive process the FIR is updated as little as possible suchthat if the price history is applied to the new FIR, it stillgenerates the exact price. Let \(L\) be the length of price history and\(p(n)\) be the price tick at time point \(n\) then&lt;/p&gt;&lt;p&gt;\begin{equation*}\boldsymbol{p}(n)=\Big(p(n),p(n-1),\dotsc,p(n-L+1)\Big)^T\end{equation*}&lt;/p&gt;&lt;p&gt;is a vector containing \(L\) recent price ticks. The objective is to findimpuls response&lt;/p&gt;&lt;p&gt;\begin{equation*}\boldsymbol{h}(n)=\Big(h_1(n),h_2(n),\dotsc,h_L(n)\Big)^T\end{equation*}&lt;/p&gt;&lt;p&gt;such that it is as close as possible to the previous FIR,i.e. \(\boldsymbol{h}(n-1)\), and at the same time pefectly predicts thenext price tick,i.e. \(\boldsymbol{h}^T(n)\boldsymbol{p}(n)=p(n+1)\). This can beformulated as the following optimization problem:&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:norm2}\min\quad\Big\|\boldsymbol{h}(n)-\boldsymbol{h}(n-1)\Big\|_2^2\end{equation}&lt;/p&gt;&lt;p&gt;subject to&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:pred}\boldsymbol{h}^T(n)\boldsymbol{p}(n)=p(n+1).\end{equation}&lt;/p&gt;&lt;p&gt;Using the method of Lagrange multiplier, it can be shown that&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:raw:nlms}\boldsymbol{h}(n)=\boldsymbol{h}(n-1)+\frac{e(n)\boldsymbol{p}(n)}{\boldsymbol{p}^T(n)\boldsymbol{p}(n)}\end{equation}&lt;/p&gt;&lt;p&gt;where&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:prederr}e(n)=p(n+1)-\boldsymbol{h}^T(n-1)\boldsymbol{p}(n)\end{equation}&lt;/p&gt;&lt;p&gt;This adaptive approach can be used to predict the price of anasset. The quality of prediction can be assessed by its convergencemeasured by \(\eqref{eq:norm2}\) and the prediction error estimated by\(\eqref{eq:prederr}\). When both of the criteria are small, theprediction is probably precise.&lt;/p&gt;&lt;h2 id=&#34;relation-to-echo-cancellation&#34;&gt;Relation to echo cancellation&lt;/h2&gt;&lt;p&gt;Echo cancellation is the process of removing echo in a signal, forexample removing acoustic echo in a telephone call. A populartechnique to cancel acoustic echo is to identify echo via systemidentification, the same approach which is used in this post for priceprediction. To turn our price predictor to an echo canceler, it isonly enough to fill \(\boldsymbol{p}(n)\) vector with the last \(L\) audiosamples coming from the speaker instead of price ticks and replace\(p(n+1)\) with microphone signal in \(\eqref{eq:pred}\). Then,\(\eqref{eq:raw:nlms}\) identifies the FIR of an acoustic echocanceler. This approach to echo cancellation is referred to as&lt;em&gt;normalised least mean square&lt;/em&gt; method, which will be discussed in thenext section. That is to say, the system which predicts the currentprice actually produces an echo of past prices that best matches thecurrent priced.&lt;/p&gt;&lt;h2 id=&#34;normalized-least-mean-square&#34;&gt;Normalized least mean square&lt;/h2&gt;&lt;p&gt;A price predictor, an echo canceler, or any other unknown system canbe identified by &lt;em&gt;normilized least mean square&lt;/em&gt; (NLMS) method. Theprocedure follows the computation given by \(\eqref{eq:raw:nlms}\) and\(\eqref{eq:prederr}\). It takes the signal value at each time point,computes the predicted system output, compares it with the real outputto estimate error and then accordingly updates the impuleresponse. NLMS however adds two parameters to have finer control overrecursion \(\eqref{eq:raw:nlms}\). How much the FIR is updated is alsocontrolled by step size (\(\alpha\)) and regularization parameter(\(\delta\)).&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:nlms}\boldsymbol{h}(n)=\boldsymbol{h}(n-1)+\frac{\alpha e(n)\boldsymbol{p}(n)}{\boldsymbol{p}^T(n)\boldsymbol{p}(n)+\delta}\end{equation}&lt;/p&gt;&lt;p&gt;Bigger step size causes \(\eqref{eq:nlms}\) to converge faster, likelywith higher error estimation error. To decrease error, smaller stepsize should be taken, which subsequently requires more iterationsuntil convergence. For numerical stability, \(\alpha\) must lie between0 and 2. Regularization parameter \(\delta\) helps system identificationperforming well in case the signal is noisy.&lt;/p&gt;&lt;h2 id=&#34;python-implementation&#34;&gt;Python implementation&lt;/h2&gt;&lt;p&gt;The implemention of NLMS algorithm on price data isstraightforward. It is enough to update the impule responseiteratively according to \(\eqref{eq:nlms}\). The algorithm has threeparameters:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;\(L\) is the length of price history&lt;/li&gt;&lt;li&gt;\(\alpha\) is the step size&lt;/li&gt;&lt;li&gt;\(\delta\) is the regularization parameter&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These parameters are passed while constructing an object of&lt;code&gt;system_identifier&lt;/code&gt;. This class provides system identificationfunctionality.&lt;/p&gt;&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/hhatefi/85bd1bc50f229ad892d8e143710f5ef3.js&#34;&gt;&lt;/script&gt;&lt;p&gt;In this class, &lt;code&gt;update_filter&lt;/code&gt; takes the new price value, computes theerror and updates the FIR via \(\eqref{eq:prederr}\) and\(\eqref{eq:nlms}\), respectively. At the end it returns the predictedprice and the absolute value of update vector i.e.&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:h:diff}\Big\|\boldsymbol{h}(n)-\boldsymbol{h}(n-1)\Big\|_2^2\end{equation}&lt;/p&gt;&lt;p&gt;This is an indicator of convergence and together with the predictionerror can be used to estimate the quantity of prediction.&lt;/p&gt;&lt;figure class=&#34;diag&#34;&gt;&lt;img src=&#34;https://hhatefi.github.io/ox-hugo/pred_result.svg&#34;         alt=&#34;Figure 2: Prediction Result&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Figure 2: Prediction Result&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;To evaluate the algorithm, I use it to predict minutely price ofbitcoin from 01.09.2021 to 12.09.2021. After running the algorithm, ittakes some time for it to converge. Convergence means the estimatedFIR does not fluctuate or change rapidly and thereby is stable forprice prediction. The top diagram shows the convergence that isestimated by computing the distance between consecutive FIR asspecified by \(\eqref{eq:h:diff}\). The lower values imply that thepredicted FIR only needs to change very slightly. However, to judgethe quality of convergence, we should look at the relative error inthe bottom diagram. When both of these values are relatively small,the quality of prediction is good.&lt;/p&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;This post is proposed an algorithm for asset price prediction based onsystem identification problem. The algorithm adapts continuously withprice change and provides indicators for prediction error andconvergence. The indicators jointly can demonstrate how precise theprice estimation for the asset is.&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Testing Trading Strategies using Binance testnet API</title>
       <link>https://hhatefi.github.io/posts/binance_testnet/</link>
       <pubDate>Thu, 17 Jun 2021 22:28:00 +0200</pubDate>
       
       <guid>https://hhatefi.github.io/posts/binance_testnet/</guid>
       <description>&lt;p&gt;Algo traders most often test their strategies before jumping into livetrading. Backtesting certainly helps to evaluate and to estimate theperformance and the risk of trading strategies. However, it is oftenrequired to examine trade strategies using a demo account with virtualmoney, as &lt;em&gt;past performance is no guarantee of future results&lt;/em&gt;. Inthis article, I focus on cryptocurrency trading in &lt;a href=&#34;https://www.binance.com&#34;&gt;Binance&lt;/a&gt; and explainhow to test trading strategies there using a demo account.&lt;/p&gt;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Binance provides test platforms for &lt;a href=&#34;https://testnet.binance.vision/&#34;&gt;spot&lt;/a&gt;, &lt;a href=&#34;https://testnet.binancefuture.com/&#34;&gt;future&lt;/a&gt; and &lt;a href=&#34;https://testnet.binanceops.com/&#34;&gt;vanillaoptions&lt;/a&gt;. Depending on the type of trading, any of these platforms canbe employed to emulate strategies. In this post, I focus on spottrading and explain with an example how to use it on binance testnetplatform. Note that there is one limitation of spot testnet platformcurrently, that is it resets the positions roughly every month. Thatmight be problematic for low-frequency trading strategies. Theadvantage is, thanks to &lt;a href=&#34;https://github.com/sammchardy/python-binance&#34;&gt;&lt;code&gt;python-binance&lt;/code&gt;&lt;/a&gt;, the implemented strategy ontestnet platform can be directly used for real live spot tradingsimply by changing the API key and the secret!&lt;/p&gt;&lt;p&gt;Before starting with the implementation, the environment must be setup. We need python 3 with package &lt;a href=&#34;https://github.com/sammchardy/python-binance&#34;&gt;&lt;code&gt;python-binance&lt;/code&gt;&lt;/a&gt;, an API key and anAPI secret to establish connection to the binance testnet. First,package &lt;a href=&#34;https://github.com/sammchardy/python-binance&#34;&gt;&lt;code&gt;python-binance&lt;/code&gt;&lt;/a&gt; is required to be installed. In adevelopment environment with python 3, this can be done by:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;pip install python&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;binance&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The next step is to log into &lt;a href=&#34;https://testnet.binance.vision&#34;&gt;spot testnet platform&lt;/a&gt;. To do this, at thetime of writing this post, it is required to have a githubaccount. After login, click on &lt;code&gt;Generate HMAC_SHA256 Key&lt;/code&gt; to create anAPI key and secret and then save them for later to be used in thealgorithm. That is all we need.&lt;/p&gt;&lt;h2 id=&#34;strategy-implementation&#34;&gt;Strategy implementation&lt;/h2&gt;&lt;p&gt;Now it is the time to implement a simple strategy, which is the &amp;ldquo;helloworld&amp;rdquo; trading algorithm &lt;em&gt;moving average crossover&lt;/em&gt;. The idea is tokeep track of moving price average of an asset for a long- and ashort-term period, then, use these values to determine when to enterand exit the market. When the short-term moving average goes above thelong-term moving average we will go long; otherwise we go short, ofcourse if we hold a position in the asset. The following parametersare defined for the strategy:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;g_symbol&lt;/code&gt; is the symbol name of the asset,&lt;/li&gt;&lt;li&gt;&lt;code&gt;g_cycle&lt;/code&gt; is the operating cycle of the algorithm in seconds, thatmeans every &lt;code&gt;g_cycle&lt;/code&gt; second(s) the algorithm takes the most recentasset price, updates the moving averages and submits orders if any,&lt;/li&gt;&lt;li&gt;&lt;code&gt;g_longterm&lt;/code&gt; is the number of cycles of the long-term movingaverage. For instance if it equals 50 with &lt;code&gt;g_cycle&lt;/code&gt; being 60, theaverage over the last 50 minutely prices will be computed as thelong-term moving average,&lt;/li&gt;&lt;li&gt;&lt;code&gt;g_shortterm&lt;/code&gt; is the same as &lt;code&gt;g_longterm&lt;/code&gt; but for the short-termmoving average,&lt;/li&gt;&lt;li&gt;&lt;code&gt;g_quantity&lt;/code&gt; is the number of shares of the asset in buy and sellorders.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The complete implementation of the algorithm comes below. The codeblock to define all of the parameters is located between line 4 to 9.&lt;/p&gt;&lt;p&gt;{{&amp;lt; gist hhatefi 6eedc0d84ef8d65d31b8f5f05426ffb2 &amp;gt;}}&lt;/p&gt;&lt;p&gt;The logic of the algorithm is implemented in &lt;code&gt;SmaCrossOver&lt;/code&gt; class. Theclass also handles establishing and closing the connection to thebinance testnet platform. Moreover, it continuously fetches thecurrent price of the asset to be used for computing the short- and thelong-term moving averages. The class handles its requests to binanceplatform in an asynchronous manner. That is why, all of its methoddefinitions are followed by &lt;code&gt;async&lt;/code&gt; keyword. It implies that themethods can operate concurrently, specially if the response to arequest in a method is not ready yet, it does not block the executionof the other methods. For instance, while &lt;code&gt;fetch_price&lt;/code&gt; should wait toget the latest price of the asset, the execution can switch to &lt;code&gt;run&lt;/code&gt;to update moving averages on already available price data. This wayleads to making better use of CPU cycles by avoiding unnecessarywaiting time. The two main methods of the class are explained indetail.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;fetch_price&lt;/code&gt; uses websocket to fetch price information of the assetcontinuously using method &lt;a href=&#34;https://python-binance.readthedocs.io/en/latest/binance.html&#34;&gt;&lt;code&gt;symbol_book_ticker_socket&lt;/code&gt;&lt;/a&gt; of class&lt;code&gt;BinanceSocketManager&lt;/code&gt;. The price information contains the currentprice and the quantity of the asset available for sell (bid) or buy(ask). This information is actually the head item in thecorresponding order book, which is stored in &lt;code&gt;self._price_info&lt;/code&gt; as adictionary:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;{  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;u&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#666&#34;&gt;4751315&lt;/span&gt;,        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# order book updateId&lt;/span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;s&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;BNBUSDT&amp;#39;&lt;/span&gt;,      &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# symbol name&lt;/span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;277.50000000&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# best bid price&lt;/span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;B&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;0.04000000&amp;#39;&lt;/span&gt;,   &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# best bid quantity&lt;/span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;370.00000000&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# best ask price&lt;/span&gt;  &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;0.87000000&amp;#39;&lt;/span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# best ask quantity&lt;/span&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;run&lt;/code&gt; executes the algorithm. Each cycle, it gets the newest pricedata, which are fetched by &lt;code&gt;fetch_price&lt;/code&gt; and computes the movingaverages. At the beginning the algorithm waits for the first&lt;code&gt;g_longterm&lt;/code&gt; price ticks to come such that it has enough data pointsto compute the moving averages. Afterwards, in each cycle it updatesthe moving averages, then compares them and submits the appropriateorder if they cross each others. It is done between line 54 to 68.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Now it is the time to put all the pieces together to execute thealgorithm, which is done in function &lt;code&gt;main&lt;/code&gt;. It creates an instance ofclass &lt;code&gt;SmaCrossOver&lt;/code&gt;, which needs the API key and the API secretgenerated by binance testnet platform. Note that one can also passthose from binance spot platform and set &lt;code&gt;testnet&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt; to golive with real money instead of virtual one. After creating aninstance of &lt;code&gt;SmaCrossOver&lt;/code&gt;, the function executes &lt;code&gt;fetch_price&lt;/code&gt; and&lt;code&gt;run&lt;/code&gt; methods concurrently using &lt;code&gt;async.gather&lt;/code&gt; in line 84, whichactually runs the strategy.&lt;/p&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Binance provides platforms to test trading algorithms with virtualmoney. This enables an strategy to be evaluated in a setting that isvery close to the real trading environment with live pricedata. Testnet platform is well supported by &lt;code&gt;python-binance&lt;/code&gt; package.The implemented algorithm can be used for real live trading only bychanging the API key and secret and resetting a flag.&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Finding The Best Rate in Forex Graph</title>
       <link>https://hhatefi.github.io/posts/forex_graph/</link>
       <pubDate>Mon, 15 Mar 2021 20:32:00 +0100</pubDate>
       
       <guid>https://hhatefi.github.io/posts/forex_graph/</guid>
       <description>&lt;p&gt;Currencies are traded in pairs by simultaneously buying one andselling the other. Each pair is associated with an exchange rate,which indicates the relative price of the first currency with respectto the second one. For instance pair &lt;code&gt;EUR_USD&lt;/code&gt; with rate 1.2 showsevery Euro values 1.2 US dollar. Let say you want to change your Eurosto US dollars and want to get the best rate possible. One way is ofcourse to change them directly to dollar with rate 1.2. You require tosubmit only one trade. But maybe, you get a better rate if you firstsell the Euros and get some Japanese yens and then change the yens toUS dollar. This includes two trades, which imposes the uncertaintycoming from two order executions. In this post, I explain how to getthe best rate between two currencies, possibly through someintermediate currency exchanges when the maximum number of trades isrestricted.&lt;/p&gt;&lt;h2 id=&#34;formulation-and-modeling&#34;&gt;Formulation and modeling&lt;/h2&gt;&lt;p&gt;We are given a list of currency pairs with their associated bid andask rates. For each pair, the bid rate is the price of selling oneunit of the first currency with respect to the second. The ask rate issimilar but for buying one unit of the first currency. With both bidand ask rates given, it is possible to model tradable currencies as adirected graph. In this graph, currencies are modeled as nodes whichare connected by edges, provided that they are directly tradable. Thatis to say, a pair between currency \(C_1\) and \(C_2\) with bid rate \(b\)and ask rate \(a\) is simply modeled by an edge from \(C_1\) to \(C_2\) withweight \(b\) and an edge from \(C_2\) to \(C_1\) with weight\(\frac{1}{a}\). As an example, assume &lt;code&gt;EUR_USD&lt;/code&gt; is traded with bid rate1.2 and ask rate 1.4, then the edge between &lt;code&gt;EUR&lt;/code&gt; to &lt;code&gt;USD&lt;/code&gt; has weight1.2 and the edge between &lt;code&gt;USD&lt;/code&gt; to &lt;code&gt;EUR&lt;/code&gt; has weight\(\frac{1}{1.4}=\frac{5}{7}\). The following example shows how toconstruct the graph, given the list of currency pairs.&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&#34;text-align:center&#34;&gt;pair&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;bid&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;ask&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;EUR_USD&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.21048&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.21090&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;EUR_GBP&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.87052&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.87113&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;EUR_CHF&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.07987&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.08110&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;GBP_USD&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.38998&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.39058&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;GBP_CHF&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.23988&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.24138&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&#34;text-align:center&#34;&gt;USD_CHF&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.89199&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.89280&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;The result is a directed graph with four nodes and 12 edges. Since allcurrencies are directly tradable, the graph is complete, i.e. eachcurrency is connected to all others via a direct edge. The edges are,depending on their direction, associated either with the bid or withthe ask rate. Their weights are computed as explained above.&lt;/p&gt;&lt;figure class=&#34;diag&#34;&gt;&lt;img src=&#34;https://hhatefi.github.io/ox-hugo/forex_graph.svg&#34;         alt=&#34;Figure 1: The graph associated with the above table&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Figure 1: The graph associated with the above table&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Now assume we want to compute the rate from EUR to GBP through USD asthe intermediate currency. That is equivalent to taking path\(\mathrm{EUR}\rightarrow\mathrm{USD}\rightarrow\mathrm{GBP}\) in theforex graph. The rate is computed by multiplying the rates of eachedge along the path, which is \(0.87048=1.21048\times0.71912\). Thisvalue is the &lt;em&gt;multiplicative distance&lt;/em&gt; from EUR to GBP via USD in thegraph. In general, the rate between two currencies through a certainpath coincides with multiplicative distance between them. Themultiplicative distance from \(c_1\) to \(c_n\) through path\(c_1\rightarrow c_2\rightarrow\cdots\rightarrow c_n\) is computed by&lt;/p&gt;&lt;p&gt;\begin{equation*}\prod_{i=1}^{n-1}w(c_i,c_{i+1})\end{equation*}&lt;/p&gt;&lt;p&gt;where \(w(c_i,c_{i+1})\) is the weight of the edge from \(c_i\) to\(c_{i+1}\), i.e. the direct rate of selling \(c_i\) and buying\(c_{i+1}\). This path composed of \(n-1\) consecutive trades. In practicewe may want to restrict the number of trades, i.e. considering onlypaths up to a certain length. Each of those paths gives one rate, withthe maximum one being the best rate. Formally speaking, for a givencurrency \(c\) and the maximum number of trades \(T\), we want to computethe maximum rate from \(c\) to any other currency by doing at most \(T\)trades. This is equivalent to the maximum multiplicative distance from\(c\) to any other currency considering the paths with length of at most\(T\).&lt;/p&gt;&lt;h2 id=&#34;dynamic-programming&#34;&gt;Dynamic programming&lt;/h2&gt;&lt;p&gt;The maximum multiplicative distance can be computed in a similar wayas the shortest path in a graph. However, the length of paths, whichis equivalent to the number of trades, is bounded. That is notusually the case in classical variations of &lt;a href=&#34;https://en.wikipedia.org/wiki/Shortest%5Fpath%5Fproblem&#34;&gt;shortest pathproblem&lt;/a&gt;. Moreover, the shortest path is indeed the minimum additivedistance, which is different than &lt;em&gt;the maximum bounded multiplicativedistance&lt;/em&gt; needed here. In order to adapt shortest path computation tobounded multiplicative distance maximization, I use a variant of&lt;a href=&#34;https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford%5Falgorithm&#34;&gt;Bellman-Ford algorithm&lt;/a&gt;. The core of Bellman-Ford algorithm is arecursive formula which updates the shortest path iteratively. Thisformula is required to be adapted to multiplicative distancemaximization as follows:&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:rec}R_c(d,t+1)=\max_{(u,d)\in E}\left\{R_c(u,t)*w(u,d)\right\}\end{equation}&lt;/p&gt;&lt;p&gt;where \(R_c(d,t)\) is the maximum multiplicative distance from \(c\) to\(d\) over paths of length \(t\) and \(E\) is the set of edges in the forexgraph. The idea is to extend the maximum multiplicative distance overpaths of length \(t\) by attaching a single edge to it. It establishesthe maximum multiplicative distance over paths of length \(t+1\). Intrading world, we find all currencies that can be directly exchangedto \(d\), use them as the middle currency and choose the one that givesthe best rate. The middle currency that gives the best result is the&lt;em&gt;t-th vertex&lt;/em&gt; on the optimal path. By storing the middle currencies ineach iteration, we can construct the optimal path. An implementationof the algorithm in python is given below.&lt;/p&gt;&lt;p&gt;{{&amp;lt; gist hhatefi 887106de7aeb458d61c456fd4286d724 &amp;gt;}}&lt;/p&gt;&lt;p&gt;The algorithm is basically computes the best rates according to therecursion described by \(\eqref{eq:rec}\). This operations is repeated\(T\) times, each time for all currencies in the graph. Therefore, thecomplexity of the algorithm is quadratic in the number of currenciesand linear in the number of trades.&lt;/p&gt;&lt;p&gt;The forex graph is passed as variable &lt;code&gt;graph&lt;/code&gt;, which stores theadjacency matrix of the graph. That is to say, &lt;code&gt;graph[c][d]&lt;/code&gt; is therate of exchanging currency &lt;code&gt;c&lt;/code&gt; to &lt;code&gt;d&lt;/code&gt;. Other inputs are the sourcecurrency &lt;code&gt;src&lt;/code&gt; and the maximum number of trades &lt;code&gt;T&lt;/code&gt;. As the output, itreturns two tables both with &lt;code&gt;T+1&lt;/code&gt; rows. Each column is associatedwith a currency. The rates are stored in &lt;code&gt;dist&lt;/code&gt; table, where&lt;code&gt;dist[t,c]&lt;/code&gt; stores the best rate from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt; by doing &lt;code&gt;t&lt;/code&gt;trades. The optimal path i.e. the middle currencies are stored in&lt;code&gt;pre&lt;/code&gt;. For example, &lt;code&gt;pre[t,c]&lt;/code&gt; indicates the middle currency rightbefore &lt;code&gt;c&lt;/code&gt; along the optimal path from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;&lt;p&gt;Forex trading rates can be aggregated and modeled by a graph. Doing soenables us to conduct certain analysis on the forex graph in order toanswer some questions in the trading world. As an example, we haveseen that an adaptation of shortest path algorithm can be used forcomputing the maximum rate between two currencies when there is anupper bound on the number of trades.&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Portfolio Optimization</title>
       <link>https://hhatefi.github.io/posts/portfolio_opt/</link>
       <pubDate>Thu, 14 Jan 2021 15:02:25 +0100</pubDate>
       
       <guid>https://hhatefi.github.io/posts/portfolio_opt/</guid>
       <description>&lt;p&gt;Modern portfolio theory provides a framework to address assetallocation problem and construct portfolios. The idea was first putforward by Harry Markowitz in 1952 and since then has been enhancedboth in theory and practice and found its application in financialindustry. In this post, I formulate asset allocation problem andexplain with a simple example how to solve it using mean-varianceoptimization.&lt;/p&gt;&lt;h2 id=&#34;problem-formulation-as-mean-variance-optimization&#34;&gt;Problem formulation as mean-variance optimization&lt;/h2&gt;&lt;p&gt;Assume an investor has to select a portfolio comprised of \(N\) riskyassets. The investor&amp;rsquo;s selection is represented by vector \(\boldsymbolw=(w_1, w_2,\dotsc,w_N)^T\), where \(w_i\) denotes the fraction of thecapital invested in asset \(i\). The fractions should indeed sum up toone:&lt;/p&gt;&lt;p&gt;\[\sum_{i=1}^{N}w_i = 1\]&lt;/p&gt;&lt;p&gt;Assume for the moment that short selling is possible, which meansweights can be negative. Now if the return of each asset is known, itwill be possible to quantify the performance of theportfolio. However, asserts are risky, which means their returns varyand so does the portfolio return. Therefore, portfolio and assetreturns are modeled as random variables. Let random variable \(R_i\)denote the return of asset \(i\) and so random vector \(\boldsymbolR=(R_1,R_2,\dotsc,R_N)^T\) be the return of all assets. The overallreturn of the portfolio is then specified by random variable&lt;/p&gt;&lt;p&gt;\[R_p=\sum_{i=1}^{N}w_iR_i=\boldsymbol w^T\boldsymbol R\]&lt;/p&gt;&lt;p&gt;Moreover, let \(\boldsymbol\mu=(\mu_1,\mu_2,\dotsc,\mu_N)^T\) be thevector of expected returns, where \(\mu_i\) is the expected return ofasset \(i\), i.e. \(\mu_i=E(R_i)\). The performance of the portfolio canthen be assessed by its expected return \(\mu_p=\boldsymbolw^T\boldsymbol\mu\). Now the question is how to quantify the risk of theportfolio. Markowitz used the overall variance of the portfolio, whichis the variance of random variable \(R_p\), as the risk measure. It isnot hard to see that the variance can be computed as follows:&lt;/p&gt;&lt;p&gt;\[\sigma_p=\boldsymbol w^T\Sigma\boldsymbol w\]&lt;/p&gt;&lt;p&gt;where \(\Sigma=\{\sigma_{ij}\}_{1\le i,j\le N}\) is the covariancematrix of asset returns with \(\sigma_{ij}\) being the covariancebetween the return of asset \(i\) and \(j\).&lt;/p&gt;&lt;p&gt;Modern portfolio theory tries to select portfolios by offering atrade-off between their risk and return. It aims to compute the leastrisky portfolio for a given return level or the most profitableportfolio entailing a predefined risk level. It can be formulated as anoptimization problem in variant ways. Here, I explain the &lt;em&gt;riskminimization&lt;/em&gt; formulation, where the portfolio risk is subject tominimization while its expected return is kept at a predefined level.\[ \min~\boldsymbol w^T \Sigma \boldsymbol w \] subject to&lt;/p&gt;&lt;p&gt;\begin{align*}\boldsymbol w^T \boldsymbol u&amp;amp;=\mu_0\\\boldsymbol w^T\boldsymbol 1&amp;amp;=1\end{align*}&lt;/p&gt;&lt;p&gt;where \(\boldsymbol 1=(1,1,\dotso,1)^T\) denotes all-one vector. Thelast constraint assures that the asset weights sum up toone. Basically, the optimization problem computes asset weights\(\boldsymbol w\) in such a way that the constructed portfolio involvesthe minimum possible risk and furthermore produces a desired returngiven by \(\mu_0\). Portfolio managers usually add more complicatedconstraints and objective terms to change this formulation based ontheir own requirements. For the sake of simplicity, I consider onlythe above optimization problem without any extra constraints andobjective terms.&lt;/p&gt;&lt;h3 id=&#34;computing-the-efficient-frontier&#34;&gt;Computing the efficient frontier&lt;/h3&gt;&lt;p&gt;This section demonstrates the set of all efficient portfolios that areselected by the above optimization problem. The risk minimizationformulation chooses for any given level of expected return theportfolio with the minimum risk from the set of all possibleportfolios. Such minimum variance portfolios for different expectedreturns constitute a set, which is called &lt;em&gt;efficient frontier&lt;/em&gt;. Inorder to find this set, the optimization problem should be solved forall given expected returns. The risk minimization formulation,described above, is a quadratic optimization problem with equalityconstraints and has an analytical solution. The problem can be solvedusing the method of Lagrange multipliers (see e.g. Fabozziet. al. 2010, Section 8) with the solution given by:&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:ef}\sigma_0^2=\frac{A\mu_0^2-2B\mu_0+C}{AC-B^2}\end{equation}&lt;/p&gt;&lt;p&gt;where \(A=\boldsymbol 1^T\Sigma^{-1}\boldsymbol 1\), \(B=\boldsymbol1^T\Sigma^{-1}\boldsymbol\mu\) and \(C=\boldsymbol\mu^T\Sigma^{-1}\boldsymbol\mu\). According to Equation \(\eqref{eq:ef}\), theminimum variance \(\sigma_0^2\) of a portfolio form a quadratic functionof \(\mu_0\). This quadratic function has a minimum value, whichcorresponds to the portfolio with the global minimum variance. This can becomputed by:&lt;/p&gt;&lt;p&gt;\[\frac{\mathrm{d}\sigma_0^2}{\mathrm{d}\mu_0}=\frac{2A\mu_0-2B}{AC-B^2}=0\Rightarrow\mu_0=\frac{A}{B}=\frac{\boldsymbol 1^T\Sigma^{-1}}{\boldsymbol 1^T\Sigma^{-1}\boldsymbol 1}\boldsymbol\mu\]&lt;/p&gt;&lt;p&gt;Since we know that \(\mu_0=\boldsymbol w^T\boldsymbol\mu\) then theglobal minimum variance portfolio becomes:&lt;/p&gt;&lt;p&gt;\[\boldsymbol w_{\mathrm{min}}=\frac{\Sigma^{-1}\boldsymbol 1}{\boldsymbol 1^T\Sigma^{-1}\boldsymbol 1}\]&lt;/p&gt;&lt;p&gt;This portfolio is not interesting only because it is the least riskyone, but also because its construction does not require any estimationof expected returns (vector \(\boldsymbol\mu\)). That is important, assuch an estimation is subject to error and uncertainty, particularlyif it relies on historical price data.&lt;/p&gt;&lt;p&gt;With all the formulas given above, computing the efficient frontierwill be straightforward. At first we pick up our universe, the set ofall assets we want to invest in and then download their pricedata. The follwing python code uses &lt;code&gt;yfinance&lt;/code&gt; package for thispurpose.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;yfinance&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;yf&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;numpy&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;np&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;pandas&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;pd&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;plt&lt;/span&gt;assets &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;GOOG MA AMZN GM AAPL&amp;#34;&lt;/span&gt;data &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; yf&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;download(assets, start&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;2019-01-01&amp;#34;&lt;/span&gt;, end&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;2019-12-31&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Adj Close&amp;#39;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;One of the main challenges of portfolio optimization is the estimationof expected returns \(\boldsymbol\mu\) and the covariance matrix\(\Sigma\). One approach is to estimate them by sample mean andcovariance, respectively. However, it is known to provide poorestimation and to show high sensitivity to price fluctuation,specially for expected returns. There are several other estimationsthat are generally considered more precise and more stable. Package&lt;code&gt;pyopt&lt;/code&gt; provides different models for computing expected returns andthe covariance matrix. Here we use exponential moving average modelfor expected returns and exponential covariance for the covariancematrix.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;mu&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;expected_returns&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;return_model(data, method&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;ema_historical_return&amp;#39;&lt;/span&gt;)sigma&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;risk_models&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;risk_matrix(data, method&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;exp_cov&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now all the ingredients are ready to derive the efficient frontier.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;plt&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;math&lt;/span&gt;sigma_inv&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;linalg&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;inv(sigma)all_ones&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;ones(sigma&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;shape[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;])A&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;all_ones&lt;span style=&#34;color:#a2f&#34;&gt;@sigma_inv@all_ones&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;all_ones&lt;span style=&#34;color:#a2f&#34;&gt;@sigma_inv@mu&lt;/span&gt;C&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;mu&lt;span style=&#34;color:#a2f&#34;&gt;@sigma_inv@mu&lt;/span&gt;delta&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;A&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;C&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;Bcompute_risk&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;lambda&lt;/span&gt; mu0: np&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;sqrt((A&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;mu0&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;mu0 &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;mu0 &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; C) &lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt; delta)mu0&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;np&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;linspace(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;3.5&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;40&lt;/span&gt;)sigma0&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;compute_risk(mu0)plt&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;plot(sigma0, mu0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result is illustrated in the next diagram.&lt;/p&gt;&lt;figure class=&#34;diag&#34;&gt;&lt;img src=&#34;https://hhatefi.github.io/ox-hugo/ef.svg&#34;         alt=&#34;Figure 1: Efficient frontier without risk free asset&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Figure 1: Efficient frontier without risk free asset&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;As it can be observed, increasing the expected return (\(\mu_0\)) leadsto portfolios that take higher risks. Selecting a portfolio with lowerrisk, on the other hand, decrease its performance as well.&lt;/p&gt;&lt;p&gt;We can also calculate the global minimum portfolio weights, its riskand return characteristics.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;gmin_mu0&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;A                       &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# the expected return at the global minimum risk&lt;/span&gt;gmin_sigma0&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;compute_risk(gmin_mu0) &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# the global minimum risk&lt;/span&gt;w_gmin&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;sigma_inv&lt;span style=&#34;color:#a2f&#34;&gt;@all_ones&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;A        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# the global minimum risk portfolio&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;AAPL&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;AMZN&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;GM&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;GOOG&lt;/th&gt;&lt;th style=&#34;text-align:center&#34;&gt;MA&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Weights&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;9.62%&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;22.08%&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;23.46%&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;19.48%&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;25.37%&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Return&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;1.04&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.19&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.10&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.32&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.53&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Risk&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.22&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.20&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.24&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.21&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;0.21&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&#34;capital-market-line-and-the-tangency-portfolio&#34;&gt;Capital market line and the tangency portfolio&lt;/h2&gt;&lt;p&gt;Investors can add a risk free asset to improve the performance oftheir portfolio. A risk free asset is an asset with a fixed return\(R_f\) that might be selected by investors together with a combinationof \(N\) risky assets as before. On the efficient frontier allportfolios comprises of only risky assets. Adding the risk-free assetimplies that the weights of risky assets do not necessarily sum up toone, as the difference is invested in the risk free asset. Therefore,both risky and risk-free assets contributes to the expected return ofthe portfolio:&lt;/p&gt;&lt;p&gt;\begin{align*}\mu_p=&amp;amp;\boldsymbol w^T\boldsymbol\mu+(1-\boldsymbol w^T\boldsymbol 1)R_f\\\\\end{align*}&lt;/p&gt;&lt;p&gt;However, the overall portfolio risk depends only on the risky assets,since the risk free asset has zero variance and is independent of therisky assets.&lt;/p&gt;&lt;p&gt;\begin{align*}\sigma_p=&amp;amp;\boldsymbol w^T\Sigma\boldsymbol w\end{align*}&lt;/p&gt;&lt;p&gt;Putting the risk and the return of the portfolio into risk minimizationformulation gives:&lt;/p&gt;&lt;p&gt;\[\min~\boldsymbol w^T\Sigma\boldsymbol w\]subject to\[\mu_0=\boldsymbol w^T\boldsymbol\mu+(1-\boldsymbol w^T\boldsymbol 1)R_f\]&lt;/p&gt;&lt;p&gt;The optimization problem can again be solved by the method of Lagrangemultipliers. The optimal portfolio weights are derived as follows:&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:wrf}\boldsymbol w=K\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)\end{equation}&lt;/p&gt;&lt;p&gt;where\[K=\frac{\mu_0-R_f}{(\boldsymbol\mu-R_f\boldsymbol 1)^T\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)}=\frac{\mu_0-R_f}{AR_f^2-2R_fB+C}\]&lt;/p&gt;&lt;p&gt;In order to illustrate the relation between the risk and the return,we can derive \(\sigma_0^2\) as a function of \(\mu_0\) using\eqref{eq:wrf}:&lt;/p&gt;&lt;p&gt;\begin{equation*}\sigma_0^2=\boldsymbol w^T\Sigma\boldsymbol w=\frac{(\mu_0-R_f)^2}{(\boldsymbol\mu-R_f\boldsymbol 1)^T\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)}=\frac{(\mu_0-R_f)^2}{AR_f^2-2R_fB+C}\end{equation*}&lt;/p&gt;&lt;p&gt;This time the expected return and its corresponding minimal risk lieon a line. For \(\mu_0\ge R_f\):&lt;/p&gt;&lt;p&gt;\begin{equation}\label{eq:cml}\sigma_0=\frac{\mu_0-R_f}{\sqrt{(\boldsymbol\mu-R_f\boldsymbol 1)^T\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)}}=\frac{\mu_0-R_f}{\sqrt{AR_f^2-2R_fB+C}}\end{equation}&lt;/p&gt;&lt;p&gt;There are two specially interesting portfolios on line\eqref{eq:cml}. The portfolio with zero risk coincides with \(\mu_0\)being \(R_f\), which contains only the risk free asset. On the otherside, there is a portfolio comprising merely the risky assets. Becauseit only includes the risky assets, it must also lie on the efficientfrontier, represented by \eqref{eq:ef}. Therefore, this portfolio islocated on the intersection between \eqref{eq:ef} and\eqref{eq:cml}. In addition, it can be shown that \eqref{eq:cml} is atangent line to \eqref{eq:ef}. The portfolio at the intersection pointis thereby called &lt;em&gt;tangancy portfolio&lt;/em&gt;. Under certain condition (Fama1970), it is also named as &lt;a href=&#34;https://en.wikipedia.org/wiki/Market%5Fportfolio&#34;&gt;&lt;em&gt;market portfolio&lt;/em&gt;&lt;/a&gt;. Moreover, line\eqref{eq:cml} is referred to as the &lt;em&gt;Capital Market Line&lt;/em&gt; (CML).&lt;/p&gt;&lt;p&gt;To compute the tangency portfolio, it is enough to find theintersection between \eqref{eq:cml} and \eqref{eq:ef}. As explainedbefore, the intersection embodies only the risky assets. Let\(\boldsymbol w_m\) be the market portfolio, then it holds that\(\boldsymbol w_m^T\boldsymbol 1=1\), as the weight of risk free asset iszero. Therefore:&lt;/p&gt;&lt;p&gt;\[\boldsymbol w^T\boldsymbol 1=\left(K\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)\right)^T\boldsymbol 1=1\Rightarrow K=\frac{1}{\boldsymbol 1^T\Sigma(\boldsymbol\mu-R_f\boldsymbol 1)}\]&lt;/p&gt;&lt;p&gt;And finally substituting \(K\) into \(\eqref{eq:wrf}\) gives the marketportfolio:\[\boldsymbol w_m=\frac{\Sigma^{-1}(\boldsymbol\mu-R_f\boldsymbol 1)}{\boldsymbol 1^T\Sigma(\boldsymbol\mu-R_f\boldsymbol 1)}\]&lt;/p&gt;&lt;p&gt;Furthermore, putting \(\boldsymbol w_m\) into \(\mu_0=\boldsymbolw_m^T\boldsymbol\mu\) and \(\sigma_0=\boldsymbol w_m^T\Sigma\boldsymbolw_m\) gives:&lt;/p&gt;&lt;p&gt;\begin{align*}\mu_0=&amp;amp;\frac{C-BR_f}{B-AR_f}\\\sigma_0=&amp;amp;\frac{\sqrt{AR_f^2-2R_fB+C}}{B-AR_f}\end{align*}&lt;/p&gt;&lt;p&gt;Now we can put all the formulas together to compute CML and thetangency portfolio:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;math&lt;/span&gt;rf &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0.05&lt;/span&gt;D&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;A&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt;Csigma_rf&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;(mu0&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;rf)&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;math&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;sqrt(D)w_m&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;sigma_inv&lt;span style=&#34;color:#666&#34;&gt;@&lt;/span&gt;(mu &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; rf)&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;(all_ones&lt;span style=&#34;color:#a2f&#34;&gt;@sigma&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;@&lt;/span&gt;(mu &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; rf))mu_t&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;(C&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;B&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf)&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;(B&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;A&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf)sigma_t&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;math&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;sqrt(D)&lt;span style=&#34;color:#666&#34;&gt;/&lt;/span&gt;(B&lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;A&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;rf)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result is illustrated in the following figure. It can be observedthat a portfolio on the CML outperforms the corresponding portfolio onthe efficient frontier with the same risk level. That is to say,introducing the risk free asset improves the performance of theportfolio.&lt;/p&gt;&lt;figure class=&#34;diag&#34;&gt;&lt;img src=&#34;https://hhatefi.github.io/ox-hugo/ef_cml.svg&#34;         alt=&#34;Figure 2: Efficient frontier with capital market line&#34;/&gt;&lt;figcaption&gt;            &lt;p&gt;Figure 2: Efficient frontier with capital market line&lt;/p&gt;        &lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;&lt;p&gt;Modern portfolio theory utilizes mean-variance optimization toconstruct portfolios by offering a trade-off between their risk andtheir return. The optimization problem can be formulated in differentways. Risk minimization formulation computes the minimum riskportfolio for a desired expected return. Including a risk free assetinto asset universe can improve portfolio selection.&lt;/p&gt;&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;&lt;p&gt;Fabozzi et al. &amp;ldquo;Quantitative Equity Investing: Techniques andStrategies,&amp;rdquo; John Wiley &amp;amp; Sons (2010)&lt;/p&gt;&lt;p&gt;Eugene F. Fama, &amp;ldquo;Efficient Capital Markets: A Review of Theory andEmpirical Work,&amp;rdquo; Journal of Finance, 25 (1970), pp. 383-417&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>A Helper for zipline data bundles</title>
       <link>https://hhatefi.github.io/posts/zipline_bundles/</link>
       <pubDate>Sun, 06 Sep 2020 22:30:47 +0200</pubDate>
       
       <guid>https://hhatefi.github.io/posts/zipline_bundles/</guid>
       <description>&lt;p&gt;Data bundles in zipline feed trading strategies with price data duringbacktesting. Zipline comes with some data bundles including the onethat downloads price data from &lt;a href=&#34;https://www.quandl.com/data/WIKI&#34;&gt;quandl&amp;rsquo;s wiki dataset&lt;/a&gt;. However, it isoften necessary to employ custom data bundles, for example to fetchprice of assets not provided by the existing data bundles. Adding suchbundles to zipline can be error-prone and tricky. It requires severalsteps to be done from reading price data to preprocessing and feedingthem into zipline internal database. The latter step is analogousacross all data bundles. It thus makes sense to simplify the wholeprocess by focusing only on price data fetching and preprocessing andletting the rest to be done by a generic ingester. I recently tried toimplement such a &lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/&#34;&gt;generic ingester&lt;/a&gt;.&lt;/p&gt;&lt;h2 id=&#34;generic-ingester&#34;&gt;Generic Ingester&lt;/h2&gt;&lt;p&gt;Zipline requires custom data bundles to implement &lt;code&gt;ingest&lt;/code&gt; function&lt;a href=&#34;https://www.zipline.io/bundles.html#writing-a-new-bundle&#34;&gt;properly&lt;/a&gt;. The function basically writes price data and symbolinformation to zipline internal database. A &lt;em&gt;generic&lt;/em&gt; &lt;code&gt;ingest&lt;/code&gt;function, on the one hand, implements operations that are identicalfor every data bundle, and on the other hand, enables customization ofoperations that are specific to a data bundle. It can ingest pricedata from a bunch of csv files with specific format or can directlydownload them via the API provided by price data provider.&lt;/p&gt;&lt;p&gt;I have used the generic ingester to implement data bundles that&lt;/p&gt;&lt;ol&gt;&lt;li&gt;reads price data from a directory containing csv files downloadedfrom &lt;a href=&#34;https://finance.yahoo.com&#34;&gt;yahoo finance&lt;/a&gt;,&lt;/li&gt;&lt;li&gt;directly download price data from yahoo finance, thanks to&lt;a href=&#34;https://pypi.org/project/yahoofinancials/&#34;&gt;yahoofinancials&lt;/a&gt;,&lt;/li&gt;&lt;li&gt;directly download price data from &lt;a href=&#34;https://iexcloud.io&#34;&gt;IEX cloud&lt;/a&gt;, thanks to &lt;a href=&#34;https://pypi.org/project/iexfinance/&#34;&gt;iexfinance&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Looking into &lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/tree/master/lib&#34;&gt;their implementation&lt;/a&gt; greatly helps to understand how touse the generic ingester. Later in this post, however, I explain howto define a new bundle using the generic ingester in detail.&lt;/p&gt;&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;&lt;p&gt;There is a quick way to use or test the already mentioned &lt;a href=&#34;#generic-ingester&#34;&gt;data bundles&lt;/a&gt;with zipline. The first step is to get the source from github:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/hhatefi/zipline_bundles&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The repository comes with an &lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/blob/master/install.py&#34;&gt;installation script&lt;/a&gt;, which can be used toadd the data bundles to the zipline framework. Before using it, Iassume there is already an environment with zipline installed and itis ready to be used. The installation is done by&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#a2f&#34;&gt;cd&lt;/span&gt; zipline_bundlespython3 installer.py&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The installer copies the following files:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/blob/master/lib/extension.py&#34;&gt;extension.py&lt;/a&gt; to &lt;code&gt;$HOME/.zipline&lt;/code&gt;,&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/blob/master/lib/ingester.py&#34;&gt;ingester.py&lt;/a&gt;, &lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/blob/master/lib/yahoo.py&#34;&gt;yahoo.py&lt;/a&gt; and &lt;a href=&#34;https://github.com/hhatefi/zipline%5Fbundles/blob/master/lib/iex.py&#34;&gt;iex.py&lt;/a&gt; into &lt;code&gt;zipline.data.bundles&lt;/code&gt;package.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Note that the installer complains if there already exist pythonmodules with the same name in the destination directories. To forcethe installer to overwrite the existing modules, add &lt;code&gt;-f&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In general the installer copies all files listed in variable &lt;code&gt;src_ext&lt;/code&gt;into &lt;code&gt;$HOME/.zipline&lt;/code&gt; and those listed in &lt;code&gt;src_ing&lt;/code&gt; into&lt;code&gt;zipline.data.bundles&lt;/code&gt; package. In case a new bundle is added, theappropriate modules can be usually appended to &lt;code&gt;src_ing&lt;/code&gt; list. Theinstallation script can then be used to install the new bundle.&lt;/p&gt;&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;&lt;p&gt;The available bundles are listed by&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;zipline bundles&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If the installation is done successfully, it will show new bundles&lt;code&gt;yahoo_csv&lt;/code&gt;, &lt;code&gt;yahoo_direct&lt;/code&gt; and &lt;code&gt;iex&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;yahoo_csv&lt;/code&gt; bundle takes data from csv files downloaded from &lt;a href=&#34;https://finance.yahoo.com&#34;&gt;yahoofinance&lt;/a&gt;. Each file contains price data of a single asset and shall benamed as &lt;code&gt;assert_name.csv&lt;/code&gt;. The bundle reads all the csv files locatedin a directory given by environment variable &lt;code&gt;YAHOO_CSVDIR&lt;/code&gt;:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;YAHOO_CSVDIR&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;/path/to/csvdir zipline ingest -b yahoo_csv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;yahoo_direct&lt;/code&gt; directly downloads price data from &lt;a href=&#34;https://finance.yahoo.com&#34;&gt;yahoo finance&lt;/a&gt;. Thebundle extracts asset names from environment variable &lt;code&gt;YAHOO_SYM_LST&lt;/code&gt;,which holds a comma separated list of asset names, for example:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;YAHOO_SYM_LST&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;SPY,AAPL zipline ingest -b yahoo_direct&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gets price data of assets &lt;code&gt;SPY&lt;/code&gt; and &lt;code&gt;AAPL&lt;/code&gt;. The start and end date ofprice data ingestion can be set into variables &lt;code&gt;start_date&lt;/code&gt; and&lt;code&gt;end_date&lt;/code&gt;, respectively. The variables are passed to function&lt;code&gt;get_downloader&lt;/code&gt; where the bundle is registered in&lt;code&gt;$HOME/.zipline/extension.py&lt;/code&gt;. More information comes next.&lt;/p&gt;&lt;p&gt;&lt;code&gt;iex&lt;/code&gt; downloads price data from IEX cloud. Its usage is fairly similarto that of &lt;code&gt;yahoo_direct&lt;/code&gt;. Fetching price data from IEX cloud howeverrequires passing a valid API token, which is stored in environmentvariable &lt;code&gt;IEX_TOKEN&lt;/code&gt; and read by &lt;code&gt;iexfinance&lt;/code&gt; package. Moreover, theenvironment variable storing asset names is called &lt;code&gt;IEX_SYM_LST&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&#34;defining-new-bundles&#34;&gt;Defining new bundles&lt;/h2&gt;&lt;p&gt;In zipline a new bundle, which implements the &lt;code&gt;ingest&lt;/code&gt; function, mustbe registered in the extension module &lt;code&gt;extension.py&lt;/code&gt;, usually found in&lt;code&gt;$HOME/.zipline/&lt;/code&gt;. Here, I explain how to implement an &lt;code&gt;ingest&lt;/code&gt;function and how to register it inside the extension module. I startwith csv data bundles.&lt;/p&gt;&lt;h3 id=&#34;new-csv-data-bundle&#34;&gt;New CSV data bundle&lt;/h3&gt;&lt;p&gt;This bundle aims to read csv files from a location, to store them into&lt;code&gt;pandas.DataFrame&lt;/code&gt; objects, to preprocess and feed them into ziplineinternal database. Most of the time for csv files, processing thecolumn name is the only thing needs to be done. We also need tospecify where the csv files are located. The registration of a csvdata bundle looks as follows:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;zipline.data.bundles&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; register&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;zipline.data.bundles.ingester&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; csv_ingesterregister(    &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;yahoo_csv&amp;#39;&lt;/span&gt;,    csv_ingester(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;YAHOO&amp;#39;&lt;/span&gt;, every_min_bar&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;False&lt;/span&gt;, &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# the price is daily&lt;/span&gt; csvdir_env&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;YAHOO_CSVDIR&amp;#39;&lt;/span&gt;, csvdir&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;/path/to/csv/dir&amp;#39;&lt;/span&gt;, index_column&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Date&amp;#39;&lt;/span&gt;, column_mapper&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Open&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;open&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;High&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;high&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Low&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;low&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Close&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;close&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Volume&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;volume&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;Adj Close&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;price&amp;#39;&lt;/span&gt;, },    ),    calendar_name&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;NYSE&amp;#39;&lt;/span&gt;,)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As mentioned before, the registration is done in&lt;code&gt;$HOME/.zipline/extension.py&lt;/code&gt;. The &lt;code&gt;ingest&lt;/code&gt; function is defined bycreating an object of type &lt;code&gt;csv_ingester&lt;/code&gt;, which is a functor. Theparameters are as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&#39;YAHOO&#39;&lt;/code&gt; is an arbitrary name for the exchange providing data.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;every_min_bar&lt;/code&gt; indicates the price frequency. When it is &lt;code&gt;true&lt;/code&gt;,the prices in csv files are supposed to be reported per minute.Otherwise they are expected to be stored daily.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;csvdir_env&lt;/code&gt; is the name of the environment variable holding csvdirectory. It can be set, for instance, while ingesting price data:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;YAHOO_CSV&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;/path/to/csvdir zipline ingest -b yahoo_csv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Zipline then searches for csv files inside &lt;code&gt;/path/to/csvdir&lt;/code&gt;. Thedata bundle extracts the asset names from the filename by striping&lt;code&gt;csv&lt;/code&gt; extension from the filename. For example, it considers&lt;code&gt;AAPL.csv&lt;/code&gt; to store price data of Apple stock.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;csvdir&lt;/code&gt; is the default csv directory that is used in case theenvironment variable is not set to a valid csv directory.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;index_column&lt;/code&gt; is the column name inside csv file that stores timeand date information. The bundle reads csv files into&lt;code&gt;pandas.DataFrame&lt;/code&gt; objects with the index set to the given column.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;column_mapper&lt;/code&gt; is a dictionary to be used for renaming data columnsto comply with OHLCV format, as expected by zipline. As saidearlier, price data are stored in dataframe objects, whose columnsare identical to the corresponding columns in csv files. Renaming isnecessary if the csv files do not respect OHLCV format.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There are two other parameters passed to the &lt;code&gt;register&lt;/code&gt;function. &lt;code&gt;&#39;yahoo_csv&#39;&lt;/code&gt; is the bundle name and &lt;code&gt;calender_name&lt;/code&gt; is the&lt;a href=&#34;https://www.zipline.io/trading-calendars.html&#34;&gt;trading calendar&lt;/a&gt; on which the date and time of prices are based.&lt;/p&gt;&lt;h3 id=&#34;new-direct-data-bundle&#34;&gt;New direct data bundle&lt;/h3&gt;&lt;p&gt;This type of bundle directly downloads price data via the API providedby a data provider. The &lt;em&gt;downloader&lt;/em&gt; function is responsible to fetchprice data and deliver it to the ingester. The ingester then feeds thedata into zipline internal database. Thus, the main step is to definethe downloader. Similar to a csv ingester, a direct ingester needs tobe registered before being used by zipline. As an example, I explain,step by step, how a bundle capable of fetching data from &lt;a href=&#34;https://iexcloud.io/&#34;&gt;IEX cloud&lt;/a&gt; canbe registered and defined.&lt;/p&gt;&lt;p&gt;At first, a &lt;em&gt;downloader&lt;/em&gt; function is required to download price datavia IEX cloud API. The downloader is invoked by the ingester withappropriate parameters. It needs therefore to provide a specificsignature.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;pandas&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; Timestamp&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;iexfinance.stocks&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; get_historical_data&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;get_downloader&lt;/span&gt;(start_date,       end_date,):    &lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&amp;#34;&amp;#34;returns a downloader closure for iex cloud&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;    :param start_date: the first day on which dat are downloaded&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;    :param end_date: the last day on which data are downloaded&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;    :type start_date: str in format YYYY-MM-DD&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;    :type end_date: str in format YYYY-MM-DD&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;    dt_start&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;Timestamp(start_date)&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;date()    dt_end&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;Timestamp(end_date)&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;date()    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;downloader&lt;/span&gt;(symbol):&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&amp;#34;&amp;#34;downloads symbol price data using iex cloud API&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;:param symbol: the symbol name&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;:type symbol: str&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;df &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; get_historical_data(symbol, dt_start, dt_end, output_format&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;pandas&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; df    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; downloader&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The downloader is generated by function &lt;code&gt;get_downloader&lt;/code&gt; as aclosure. This function takes the date interval via arguments&lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt;, within which price data aredownloaded. The downloader takes the symbol name as the argument andfetches price data by calling&lt;code&gt;get_historical_data&lt;/code&gt;. &lt;code&gt;get_historical_data&lt;/code&gt; provided by package&lt;a href=&#34;https://pypi.org/project/iexfinance/&#34;&gt;iexfinance&lt;/a&gt; handles relevant REST API calls to fetch data and thenconverts and returns them as a &lt;code&gt;pandas.DataFrame&lt;/code&gt;. The return valuemust in addition comply with OHLCV format. Assume the above code blockis stored as &lt;code&gt;iex.py&lt;/code&gt; within &lt;code&gt;zipline.data.bundles&lt;/code&gt; package, the nextstep is to register a new data bundle, which uses the downloader tofetch price data from IEX cloud. The registration is done within&lt;code&gt;extension.py&lt;/code&gt;.&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;zipline.data.bundles.ingester&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; direct_ingester&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#00f;font-weight:bold&#34;&gt;zipline.data.bundles&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;import&lt;/span&gt; iexregister(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;iex&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# bundle&amp;#39;s name&lt;/span&gt; direct_ingester(&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;IEX Cloud&amp;#39;&lt;/span&gt;, every_min_bar&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;False&lt;/span&gt;, symbol_list_env&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;IEX_SYM_LST&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;# the environemnt variable holding the comma separated list of asset names&lt;/span&gt; downloader&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;iex&lt;span style=&#34;color:#666&#34;&gt;.&lt;/span&gt;get_downloader(start_date&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;2015-01-01&amp;#39;&lt;/span&gt;,   end_date&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;2020-01-01&amp;#39;&lt;/span&gt; ), ), calendar_name&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#b44&#34;&gt;&amp;#39;NYSE&amp;#39;&lt;/span&gt;,)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The bundles is called &lt;code&gt;iex&lt;/code&gt; and similar to &lt;code&gt;yahoo_csv&lt;/code&gt; uses &lt;code&gt;NYSE&lt;/code&gt;trading calendar. The &lt;code&gt;ingest&lt;/code&gt; function is defined bycreating an object of type &lt;code&gt;direct_ingester&lt;/code&gt;, which is a functor. Theparameters are as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&#39;IEX Cloud&#39;&lt;/code&gt; is an arbitrary name for the exchange providing data.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;every_min_bar&lt;/code&gt; indicates the price frequency. When it is &lt;code&gt;true&lt;/code&gt;,the prices are supposed to be reported per minute. Otherwise theyare daily prices.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;symbol_list_env&lt;/code&gt; is the name of the environment variable holding acomma separated list of asset names. It can be set, for instance,while ingesting price data:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#b8860b&#34;&gt;IEX_SYM_LST&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;SPY,AAPL,TWTR zipline ingest -b iex&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Zipline then download data for assets &lt;code&gt;SPY&lt;/code&gt;, &lt;code&gt;AAPL&lt;/code&gt; and &lt;code&gt;TWTR&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;downloader&lt;/code&gt; is the downloader function, which in this case given by&lt;code&gt;iex.get_downloader&lt;/code&gt;, defined above. Price data are downloadedbetween given &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;This helper aims to simplify the process of defining new data bundlesregardless of reading data from csv files or directly downloading themvia network. New data bundles can be added by customizing the genericingester. The user can only focus on data retrival and filtering andlet the other tasks done by the helper module.&lt;/p&gt;</description>
     </item>
   
 </channel>
</rss>
